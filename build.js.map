{"version":3,"file":"build.js","sources":["src/utils.js","src/config.js","src/main.js"],"sourcesContent":["// utility methods for EventSky\n\nexport default {\n\t/**\n\t * This provides a format for event map objects\n\t * @returns {{}}\n\t */\n\tcreateNewEventMap () {\n\t\treturn {\n\t\t\t// aggregate number of handlers for this event\n\t\t\thandlers: 0,\n\t\t\t_handlers: 0,\n\t\t\ton: {},\n\t\t\tonce: {},\n\t\t\tbeforeAll: {},\n\t\t\tafterAll: {},\n\t\t}\n\t},\n}\n","export default {\n\t/**\n\t * This method sets the events that are expected to happen in the store.\n\t * If this method is invoked, it automatically assumes the intention to\n\t * restrict to only expected events that are set explicitly.\n\t * @param events [string|array]\n\t */\n\tsetExpectedEvents (events) {\n\t\t// check if there are existing events and config.restrictToExpected is false - show warning/log\n\t\t// because it means they first assigned events then set restrictToExpected\n\n\t\tthis.config.restrictToExpected = true\n\n\t\t// todo: set this.events = {}\n\n\t\treturn this\n\t}\n}","// todo: add changelog before publish\n// todo: verify a correct singleton pattern\n// todo: in the case of React, we need to ensure handlers are removed if they don't exist, ie: cdunm\n// todo: look into cancellable handlers?\n// todo: write readme on how restrictToExpected helps predictability in teams and large apps, guide on file architecture\n\nimport utils from './utils'\nimport config from './config'\n\nclass EventSky {\n\tconstructor () {\n\t\tthis.config = {\n\t\t\trestrictToExpected: false,\n\t\t\tfirehose: false,\n\t\t}\n\n\t\tthis._config = config\n\t\tthis._utils = utils\n\t\t// map of events\n\t\tthis.events = {}\n\t\tthis._firehose = msg => this.config.firehose ? console.log(`EventSky Firehose >> ${msg}`) : null\n\n\t\t// util to setup 'when' event handlers\n\t\tconst _addEventHandler = (when) => {\n\t\t\treturn (event, handler) => {\n\t\t\t\t// verify params\n\t\t\tif (typeof event !== 'string' || event.length < 1 || typeof handler !== 'function') {\n\t\t\t\t\tconsole.warn(`EventSky warning: \"${event}\" event must be a string and handler must be a function - not set with .${when} handler`)\n\n\t\t\t\t\treturn this\n\t\t\t\t}\n\n\t\t\t\t// first check if we're restricting to expected only\n\t\t\t\tif (this.config.restrictToExpected) {\n\t\t\t\t\tif (!Object.keys(this.events).includes(event)) {\n\t\t\t\t\t\tthis._firehose(`\"${event}\" handler cannot be set because it is not an expected event \"restrictToExpected = true\"`)\n\n\t\t\t\t\t\treturn this\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ensure the event exists and is setup on the event store\n\t\t\t\tif (!this.events[event]) {\n\t\t\t\t\tthis.events[event] = this._utils.createNewEventMap()\n\t\t\t\t}\n\n\t\t\t\tthis.events[event].handlers++\n\t\t\t\tconst _handlerCount = this.events[event]._handlers++\n\t\t\t\tconst eventId = `${event}.${when}.${_handlerCount}`\n\t\t\t\tthis.events[event][when][eventId] = handler\n\n\t\t\t\treturn eventId\n\t\t\t}\n\t\t}\n\t\t// setup 'when' event handlers\n\t\tthis.on = _addEventHandler('on')\n\t\tthis.once = _addEventHandler('once')\n\t\tthis.beforeAll = _addEventHandler('beforeAll')\n\t\tthis.afterAll = _addEventHandler('afterAll')\n\t}\n\n\t/**\n\t * Remove a handler for an event, the first parameter can be and event name\n\t * or an eventId to be removed.\n\t * @param eventOrId\n\t * @param handler\n\t * @returns {EventSky}\n\t */\n\toff (eventOrId, handler) {\n\t\tObject.keys(this.events).forEach(eventName => {\n\t\t\t// iterate each 'when' event lifecycle and look for eventId or handler to remove\n\t\t\tObject.keys(this.events[eventName]).forEach(eventWhen => {\n\t\t\t\tif (!['beforeAll', 'on', 'once', 'afterAll'].includes(eventWhen)) return\n\t\t\t\t// iterate each event of the current 'when' for event\n\t\t\t\tObject.keys(this.events[eventName][eventWhen]).forEach(eventId => {\n\t\t\t\t\tconst del = (!handler && eventId === eventOrId) || (this.events[eventName][eventWhen][eventId] === handler)\n\n\t\t\t\t\tif (del) {\n\t\t\t\t\t\tdelete this.events[eventName][eventWhen][eventId]\n\t\t\t\t\t\tthis.events[eventName].handlers--\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\n\t\treturn this\n\t}\n\n\ttrigger (event, data) {\n\t\tif (this.config.restrictToExpected) {\n\t\t\tif (!Object.keys(this.events).includes(event)) {\n\t\t\t\tthis._firehose(`\"${event}\" triggered and is not an expected event \"restrictToExpected = true\"`)\n\n\t\t\t\treturn this\n\t\t\t}\n\t\t} else if (!this.events[event]) {\n\t\t\tthis._firehose(`\"${event}\" triggered with no handlers setup`)\n\n\t\t\treturn this\n\t\t}\n\n\t\tthis._firehose(`\"${event}\" triggered`)\n\n\t\t// beforeAll\n\t\tconst beforeAll = this.events[event].beforeAll\n\t\ttry {\n\t\t\tObject.keys(beforeAll).forEach(key => beforeAll[key](data))\n\t\t} catch (e) {\n\t\t\tconsole.error(`EventSky error: ${event} beforeAll handler errored`, { error: e, data: data })\n\t\t}\n\n\t\t// on\n\t\tconst on = this.events[event].on\n\t\ttry {\n\t\t\tObject.keys(on).forEach(key => on[key](data))\n\t\t} catch (e) {\n\t\t\tconsole.error(`EventSky error: ${event} on handler errored`, { error: e, data: data })\n\t\t}\n\n\t\t// once\n\t\tconst once = this.events[event].once\n\t\ttry {\n\t\t\tObject.keys(once).forEach(key => {\n\t\t\t\tonce[key](data)\n\t\t\t\t// remove handler\n\t\t\t\tthis.off(event, once[key](data))\n\t\t\t})\n\t\t} catch (e) {\n\t\t\tconsole.error(`EventSky error: ${event} once handler errored`, { error: e, data: data })\n\t\t}\n\n\t\t// afterAll\n\t\tconst afterAll = this.events[event].afterAll\n\t\ttry {\n\t\t\tObject.keys(afterAll).forEach(key => afterAll[key](data))\n\t\t} catch (e) {\n\t\t\tconsole.error(`EventSky error: ${event} afterAll handler errored`, { error: e, data: data })\n\t\t}\n\n\t\treturn this\n\t}\n}\n\nexport default new EventSky()\n"],"names":["events","config","restrictToExpected","this","_config","_utils","utils","_firehose","_this","firehose","console","log","msg","_addEventHandler","when","event","handler","length","warn","Object","keys","includes","createNewEventMap","handlers","_handlerCount","_handlers","eventId","on","once","beforeAll","afterAll","eventOrId","forEach","_this2","eventName","eventWhen","data","key","e","error","off"],"mappings":"mLAEA,qDAQa,YACC,0ECJMA,eAIbC,OAAOC,oBAAqB,EAI1BC,iWCgIM,uDApIRF,4BACgB,YACV,QAGNG,QAAUH,OACVI,OAASC,OAETN,eACAO,UAAY,kBAAOC,GAAKP,OAAOQ,SAAWC,QAAQC,4BAA4BC,GAAS,SAGtFC,GAAmB,SAACC,SAClB,UAACC,EAAOC,MAEM,gBAAVD,IAAsBA,EAAME,OAAS,GAAwB,kBAAZD,kBAClDE,2BAA2BH,6EAAgFD,mBAMhHN,EAAKP,OAAOC,qBACViB,OAAOC,KAAKZ,EAAKR,QAAQqB,SAASN,YACjCR,cAAcQ,8FAOhBP,GAAKR,OAAOe,OACXf,OAAOe,GAASP,EAAKH,OAAOiB,uBAG7BtB,OAAOe,GAAOQ,cACbC,GAAgBhB,EAAKR,OAAOe,GAAOU,YACnCC,EAAaX,MAASD,MAAQU,WAC/BxB,OAAOe,GAAOD,GAAMY,GAAWV,EAE7BU,SAIJC,GAAKd,EAAiB,WACtBe,KAAOf,EAAiB,aACxBgB,UAAYhB,EAAiB,kBAC7BiB,SAAWjB,EAAiB,kDAU7BkB,EAAWf,4BACRI,KAAKjB,KAAKH,QAAQgC,QAAQ,mBAEzBZ,KAAKa,EAAKjC,OAAOkC,IAAYF,QAAQ,aACrC,YAAa,KAAM,OAAQ,YAAYX,SAASc,WAE/Cf,KAAKa,EAAKjC,OAAOkC,GAAWC,IAAYH,QAAQ,cACxChB,GAAWU,IAAYK,GAAeE,EAAKjC,OAAOkC,GAAWC,GAAWT,KAAaV,WAG3FiB,GAAKjC,OAAOkC,GAAWC,GAAWT,KACpC1B,OAAOkC,GAAWX,kBAMpBpB,qCAGCY,EAAOqB,iBACXjC,KAAKF,OAAOC,wBACViB,OAAOC,KAAKjB,KAAKH,QAAQqB,SAASN,eACjCR,cAAcQ,0EAEZZ,SAEF,KAAKA,KAAKH,OAAOe,eAClBR,cAAcQ,wCAEZZ,UAGHI,cAAcQ,oBAGbc,GAAY1B,KAAKH,OAAOe,GAAOc,qBAE7BT,KAAKS,GAAWG,QAAQ,kBAAOH,GAAUQ,GAAKD,KACpD,MAAOE,WACAC,yBAAyBxB,gCAAqCwB,MAAOD,EAAGF,KAAMA,OAIjFT,GAAKxB,KAAKH,OAAOe,GAAOY,cAEtBP,KAAKO,GAAIK,QAAQ,kBAAOL,GAAGU,GAAKD,KACtC,MAAOE,WACAC,yBAAyBxB,yBAA8BwB,MAAOD,EAAGF,KAAMA,OAI1ER,GAAOzB,KAAKH,OAAOe,GAAOa,gBAExBR,KAAKQ,GAAMI,QAAQ,cACpBK,GAAKD,KAELI,IAAIzB,EAAOa,EAAKS,GAAKD,MAE1B,MAAOE,WACAC,yBAAyBxB,2BAAgCwB,MAAOD,EAAGF,KAAMA,OAI5EN,GAAW3B,KAAKH,OAAOe,GAAOe,oBAE5BV,KAAKU,GAAUE,QAAQ,kBAAOF,GAASO,GAAKD,KAClD,MAAOE,WACAC,yBAAyBxB,+BAAoCwB,MAAOD,EAAGF,KAAMA,UAG/EjC"}