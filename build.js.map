{"version":3,"file":"build.js","sources":["src/utils.js","src/main.js"],"sourcesContent":["// utility methods for EventSky\n\nexport default {\n\t/**\n\t * This provides a format for event map objects\n\t * @returns {{}}\n\t */\n\tcreateNewEventMap (eventName) {\n\t\treturn {\n\t\t\t// aggregate number of handlers for this event\n\t\t\thandlers: 0,\n\t\t\t_handlers: 0,\n\t\t\t_name: eventName,\n\t\t\ton: {},\n\t\t\tonce: {},\n\t\t\tbeforeAll: {},\n\t\t\tafterAll: {},\n\t\t}\n\t},\n\n\t/**\n\t * Utility used to setup 'when' handlers on parent class\n\t * @param when {string} 'on', 'beforeAll', etc.\n\t * @return function\n\t */\n\tcurryWhenHandler (when) {\n\t\treturn (event, handler) => {\n\t\t\t// verify params\n\t\t\tif (typeof event !== 'string' || event.length < 1 || typeof handler !== 'function') {\n\t\t\t\tconsole.warn(`EventSky warning: \"${event}\" event must be a string and handler must be a function - not set with .${when} handler`)\n\n\t\t\t\treturn this\n\t\t\t}\n\n\t\t\t// ensure the event exists and is setup on the event store\n\t\t\tif (!this.events[event]) {\n\t\t\t\tthis.events[event] = this._utils.createNewEventMap(event)\n\t\t\t}\n\n\t\t\t// check if the event and handler are a duplicate\n\t\t\tif (this.events[event][when] && this.events[event][when] === handler) {\n\t\t\t\tif (!this.config.ignoreDuplicateHandler) {\n\t\t\t\t\tconsole.warn(`EventSky warning: duplicate handler for .${when}('${event}')`)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.events[event].handlers++\n\t\t\tconst _handlerCount = this.events[event]._handlers++\n\t\t\tconst eventId = `id_${event}.${when}.${_handlerCount}`\n\t\t\tthis.events[event][when][eventId] = handler\n\n\t\t\treturn eventId\n\t\t}\n\t},\n\n\tvalidateEventName (context, eventName) {\n\t\tif (!context) {\n\t\t\treturn console.error('EventSky._utils needs to be passed a valid context param')\n\t\t} else if (!eventName || typeof eventName !== 'string') {\n\t\t\tconsole.error('EventSky error: .trigger(event) did not receive a string param')\n\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t},\n}\n","import utils from './utils'\n\nclass EventSky {\n\tconstructor () {\n\t\tthis.config = {\n\t\t\tfirehose: false,\n\t\t\tignoreDuplicateHandler: false, // warns about duplicate event/handler\n\t\t}\n\n\t\tthis._utils = utils\n\n\t\t// map of events\n\t\tthis.events = {}\n\t\tthis._firehose = msg => this.config.firehose ? console.log(`EventSky Firehose >> ${msg}`) : null\n\n\t\t// setup 'when' event handlers\n\t\tthis.on = this._utils.curryWhenHandler.bind(this)('on')\n\t\tthis.once = this._utils.curryWhenHandler.bind(this)('once')\n\t\tthis.beforeAll = this._utils.curryWhenHandler.bind(this)('beforeAll')\n\t\tthis.afterAll = this._utils.curryWhenHandler.bind(this)('afterAll')\n\n\t\t// extend a chain call for eventSky.off.all()\n\t\tthis.off.all = this.allOff.bind(this)\n\t}\n\n\t/**\n\t * Remove a handler for an event, the first parameter can be and event name\n\t * or an eventId to be removed.\n\t * @param eventOrId\n\t * @param handler\n\t * @returns {EventSky}\n\t */\n\toff (eventOrId, handler) {\n\t\t// iterate all events by names\n\t\tObject.keys(this.events).forEach(_eventName => {\n\t\t\t// iterate each 'when' event lifecycle and look for eventId or handler to remove\n\t\t\tObject.keys(this.events[_eventName]).forEach(_eventWhen => {\n\t\t\t\tif (!['beforeAll', 'on', 'once', 'afterAll'].includes(_eventWhen)) return\n\n\t\t\t\t// iterate each event of the current 'when' for event\n\t\t\t\tObject.keys(this.events[_eventName][_eventWhen]).forEach(_eventId => {\n\t\t\t\t\tconst eventNameAndHandlerMatch = (\n\t\t\t\t\t\t\tthis.events[_eventName][_eventWhen][_eventId] === handler &&\n\t\t\t\t\t\t\t_eventName === eventOrId\n\t\t\t\t\t\t)\n\t\t\t\t\tconst eventIdMatch = (!handler && _eventId === eventOrId)\n\n\t\t\t\t\tconst performDelete = (\n\t\t\t\t\t\t\teventNameAndHandlerMatch ||\n\t\t\t\t\t\t\teventIdMatch\n\t\t\t\t\t\t)\n\n\t\t\t\t\tif (performDelete) {\n\t\t\t\t\t\tdelete this.events[_eventName][_eventWhen][_eventId]\n\t\t\t\t\t\tthis.events[_eventName].handlers--\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Turn off all handlers for an event name\n\t * @param eventName {string} the name of the event\n\t * @returns {EventSky}\n\t */\n\tallOff (event) {\n\t\tdelete this.events[event]\n\n\t\tthis._firehose(`.off.all(\"${event}\") removed all event handlers`)\n\n\t\tthis.events[event] = this._utils.createNewEventMap()\n\n\t\treturn this\n\t}\n\n\ttrigger (event, data) {\n\t\tif (!this._utils.validateEventName(this, event)) return this\n\n\t\tif (!this.events[event]) {\n\t\t\tthis._firehose(`\"${event}\" triggered with no handlers setup`)\n\n\t\t\treturn this\n\t\t}\n\n\t\tthis._firehose(`\"${event}\" triggered`)\n\n\t\t// beforeAll\n\t\tconst beforeAll = this.events[event].beforeAll\n\n\t\tObject.keys(beforeAll).forEach(key => {\n\t\t\ttry {\n\t\t\t\tbeforeAll[key](data)\n\t\t\t} catch (e) {\n\t\t\t\tif (!beforeAll[key]) { // check if the method exists\n\t\t\t\t\tconsole.error(`EventSky error: .beforeAll('${event}', ...) handler does not exist`, { eventId: key, data: data })\n\t\t\t\t} else { // else show the method errored\n\t\t\t\t\tconsole.error(`EventSky error: .beforeAll('${event}', ${on[key].name || ('anonymous')}) handler trapped an error`, { error: e, data: data })\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\t// on\n\t\tconst on = this.events[event].on\n\n\t\tObject.keys(on).forEach(key => {\n\t\t\ttry {\n\t\t\t\ton[key](data)\n\t\t\t} catch (e) {\n\t\t\t\tif (!on[key]) { // check if the method exists\n\t\t\t\t\tconsole.error(`EventSky error: .on('${event}', ...) handler does not exist`, { eventId: key, data: data })\n\t\t\t\t} else { // else show the method errored\n\t\t\t\t\tconsole.error(`EventSky error: .on('${event}', ${on[key].name || ('anonymous')}) handler trapped an error`, { error: e, data: data })\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\t// once\n\t\tconst once = this.events[event].once\n\n\t\tObject.keys(once).forEach(key => {\n\t\t\ttry {\n\t\t\t\tonce[key](data)\n\t\t\t} catch (e) {\n\t\t\t\tif (!once[key]) { // check if the method exists\n\t\t\t\t\tconsole.error(`EventSky error: .once('${event}', ...) handler does not exist`, { eventId: key, data: data })\n\t\t\t\t} else { // else show the method errored\n\t\t\t\t\tconsole.error(`EventSky error: .once('${event}', ${on[key].name || ('anonymous')}) handler trapped an error`, { error: e, data: data })\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\t// afterAll\n\t\tconst afterAll = this.events[event].afterAll\n\n\t\tObject.keys(afterAll).forEach(key => {\n\t\t\ttry {\n\t\t\t\tafterAll[key](data)\n\t\t\t} catch (e) {\n\t\t\t\tif (!afterAll[key]) { // check if the method exists\n\t\t\t\t\tconsole.error(`EventSky error: .afterAll('${event}', ...) handler does not exist`, { eventId: key, data: data })\n\t\t\t\t} else { // else show the method errored\n\t\t\t\t\tconsole.error(`EventSky error: .afterAll('${event}', ${on[key].name || ('anonymous')}) handler trapped an error`, { error: e, data: data })\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n}\n\nexport default new EventSky()\n"],"names":["eventName","when","event","handler","length","warn","_this","events","_utils","createNewEventMap","config","ignoreDuplicateHandler","handlers","_handlerCount","_handlers","eventId","context","error","console","utils","_firehose","firehose","log","msg","on","this","curryWhenHandler","bind","once","beforeAll","afterAll","off","all","allOff","eventOrId","keys","forEach","_this2","_eventName","includes","_eventWhen","eventNameAndHandlerMatch","_eventId","eventIdMatch","data","validateEventName","key","e","name"],"mappings":"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"}